<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>018_Module</title>
  <meta name="description" content="">
  <meta name="author" content="LiJingTang">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="../../images/es6.ico">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <script type="text/javascript" charset="UTF-8">
  </script>
<body>
  <div>
    <header>
      <h1>Module</h1>
    </header>

    <div>
      <h5>1.S6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</h5>
      <h5>1-1.ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。严格模式主要有以下限制。
        <li>变量必须声明后再使用</li>
        <li>函数的参数不能有同名属性，否则报错</li>
        <li>不能使用with语句</li>
        <li>不能对只读属性赋值，否则报错</li>
        <li>不能使用前缀 0 表示八进制数，否则报错</li>
        <li>不能删除不可删除的属性，否则报错</li>
        <li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li>
        <li>eval不会在它的外层作用域引入变量</li>
        <li>eval和arguments不能被重新赋值</li>
        <li>arguments不会自动反映函数参数的变化</li>
        <li>不能使用arguments.callee</li>
        <li>不能使用arguments.caller</li>
        <li>禁止this指向全局对象</li>
        <li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li>
        <li>增加了保留字（比如protected、static和interface）</li></h5>
        <h5>2.export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</h5>
        <h5>3.export命令可以出现在模块的任何位置，只要处于模块顶层就可以。</h5>
        <h5>4.import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。</h5>
        <h5>5.由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</h5>
        <h5>6.import命令具有提升效果，会提升到整个模块的头部，首先执行。</h5>
    </div>

    <footer>
      <p>
        &copy; Copyright by LiJingTang
      </p>
    </footer>
  </div>
</body>

</html>