<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>003_const命令</title>
  <meta name="description" content="">
  <meta name="author" content="LiJingTang">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="../../images/es6.ico">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <script type="text/javascript" charset="UTF-8">
  // 6-1
  const foo = Object.freeze({});

  // 常规模式时，下面一行不起作用；
  // 严格模式时，该行会报错
  foo.prop = 123;

  var constantize = (obj) => {
    Object.freeze(obj);
    Object.keys(obj).forEach((key, i) => {
      if (typeof obj[key] === 'object') {
        constantize(obj[key]);
      }
    });
  };
  </script>
<body>
  <div>
    <header>
      <h1>const命令</h1>
    </header>

    <div>
      <h5>1.const声明一个只读的常量。一旦声明，常量的值就不能改变。</h5>
      <h5>2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</h5>
      <h5>3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。</h5>
      <h5>4.const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</h5>
      <h5>5.const声明的常量，也与let一样不可重复声明。</h5>
      <h5>6.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
      </h5>
      <h5>6-1.如果真的想将对象冻结，应该使用Object.freeze方法。</h5>
    </div>

    <footer>
      <p>
        &copy; Copyright by LiJingTang
      </p>
    </footer>
  </div>
</body>

</html>